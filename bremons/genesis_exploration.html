<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GENESIS EXPLORE</title>
    <link href="https://fonts.googleapis.com/css2?family=DotGothic16&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <style>
        /* === 基本設定 === */
        body { 
            overflow: hidden; background: #050010; touch-action: none;
            height: 100dvh; margin: 0; user-select: none;
            font-family: 'DotGothic16', sans-serif; color: #fff;
        }
        .game-container { width: 100%; height: 100%; position: relative; overflow: hidden; }
        
        /* 空間の揺らぎ */
        .game-world { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            will-change: transform; animation: world-instability 10s infinite;
        }
        @keyframes world-instability {
            0%, 90% { transform: translate(0,0); }
            91% { transform: translate(-1px, 0); } 92% { transform: translate(1px, 0); }
            100% { transform: translate(0,0); }
        }

        .sky-bg {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-image: url('./nightgame/background2.png'); background-size: cover; z-index: 0;
            filter: hue-rotate(240deg) brightness(0.6);
        }
        .ground-layer {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 160px; z-index: 10;
            background: linear-gradient(0deg, rgba(142, 68, 173, 0.2) 1px, transparent 1px), linear-gradient(90deg, rgba(142, 68, 173, 0.2) 1px, transparent 1px);
            background-size: 40px 40px; border-top: 2px solid #8e44ad;
            box-shadow: 0 -5px 20px rgba(142, 68, 173, 0.5);
        }

        .player-char {
            position: absolute; bottom: 130px; left: 15%; width: 120px; z-index: 20;
            filter: drop-shadow(0 0 5px #f093fb);
        }
        .player-walking { animation: walkBob 0.8s infinite alternate; }
        @keyframes walkBob { from { transform: translateY(0); } to { transform: translateY(-8px); } }
        .player-damage { animation: damageFlash 0.5s infinite; }
        @keyframes damageFlash { 0% { opacity: 1; } 50% { opacity: 0.2; filter: hue-rotate(90deg); } 100% { opacity: 1; } }

        /* UI関連 */
        .player-hud {
            position: absolute; bottom: 260px; left: 15%; width: 120px; height: 100px;
            z-index: 100; pointer-events: none; display: flex; flex-direction: column; 
            align-items: center; justify-content: flex-end; transform: translateX(10px); 
        }
        .voice-feedback {
            font-size: 32px; color: #f093fb; text-shadow: 2px 2px 0 #000; 
            opacity: 0; transition: opacity 0.2s; margin-bottom: 5px; white-space: nowrap;
        }
        .breath-gauge-container {
            width: 80px; height: 8px; background: #222; border: 1px solid #8e44ad; border-radius: 4px; overflow: hidden;
        }
        .breath-gauge-bar { height: 100%; width: 0%; background: #f093fb; transition: width 0.05s; }

        /* オブジェクト */
        .game-obj { position: absolute; z-index: 15; will-change: transform; }
        
        .monster-container { bottom: 135px; display: flex; flex-direction: column; align-items: center; }
        .monster-canvas {
            width: 80px; height: 80px; image-rendering: pixelated;
            animation: monsterFloat 1s infinite alternate ease-in-out;
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.5));
        }
        .monster-label {
            background: rgba(0,0,0,0.8); color: #0ff; font-size: 10px; padding: 2px 4px; border: 1px solid #0ff; margin-bottom: 2px;
        }
        @keyframes monsterFloat { from { transform: translateY(0); } to { transform: translateY(-10px); } }

        /* 隕石スタイル (回転はJS制御) */
        .meteo-obj { width: 90px; filter: hue-rotate(180deg); }
        
        .goal-obj { bottom: 130px; z-index: 18; image-rendering: pixelated; width: 60px; }

        .effect-text {
            position: absolute; font-size: 32px; font-weight: bold; 
            color: #fff; text-shadow: 2px 2px 0 #000; pointer-events: none; z-index: 100;
            animation: popUpFade 0.8s forwards;
        }
        @keyframes popUpFade { 0% { transform: translateY(0) scale(1); opacity: 1; } 100% { transform: translateY(-50px) scale(1.5); opacity: 0; } }

        /* HUDレイヤー */
        .hud-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 50; pointer-events: none; }
        .header-panel { position: absolute; top: 10px; right: 10px; display: flex; gap: 10px; pointer-events: auto; align-items: flex-start; }
        .status-box { background: rgba(0,0,0,0.8); border: 2px solid #8e44ad; padding: 8px 15px; border-radius: 8px; color: #fff; font-size: 14px; min-width: 140px; text-align: right; }
        
        .difficulty-stars { margin-bottom: 2px; display: flex; justify-content: flex-end; gap: 2px; }
        .difficulty-stars img { width: 16px; height: 16px; filter: drop-shadow(0 0 2px #fff); }
        .life-container { font-size: 16px; letter-spacing: 2px; color: #e74c3c; margin-bottom: 2px; }

        .map-panel {
            position: absolute; top: 10px; left: 10px; width: 110px; height: 110px;
            background: rgba(0, 20, 0, 0.9); border: 2px solid #2ecc71; border-radius: 4px; overflow: hidden; pointer-events: none;
        }
        .map-dot { position: absolute; width: 6px; height: 6px; border-radius: 50%; transform: translate(-50%, -50%); }
        .dot-monster { background: #f093fb; box-shadow: 0 0 4px #f093fb; }
        .dot-meteor { background: #e74c3c; }

        .navi-bubble {
            position: absolute; top: 140px; left: 20px; width: 220px;
            background: rgba(0, 0, 0, 0.85); border: 2px solid #8e44ad; border-radius: 8px;
            padding: 10px; z-index: 150; display: flex; gap: 10px; align-items: center; pointer-events: none;
            transition: opacity 0.5s; opacity: 0;
        }
        .navi-bubble.show { opacity: 1; animation: floatNavi 3s infinite ease-in-out; }
        .navi-icon { width: 36px; height: 36px; border-radius: 50%; background: #222; border: 1px solid #fff; }
        .navi-text { font-size: 12px; color: #fff; line-height: 1.4; text-align: left; }
        @keyframes floatNavi { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5px); } }

        .overlay-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 0, 10, 0.95); z-index: 200; 
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #fff; text-align: center;
        }
        .level-select-container { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 20px; }
        .level-btn {
            background: #222; border: 2px solid #8e44ad; color: #fff;
            padding: 10px; border-radius: 8px; cursor: pointer;
            width: 120px; height: 80px; display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .level-btn:hover { background: #4a235a; }
        .pixel-btn {
            background: #8e44ad; color: #fff; border: 2px solid #fff;
            padding: 12px 24px; font-size: 18px; cursor: pointer; border-radius: 5px;
            font-family: 'DotGothic16', sans-serif; margin-top: 15px;
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-world" id="gameWorld">
            <div class="sky-bg"></div>
            <div class="ground-layer" id="groundLayer"></div>
            <img src="./nightgame/chara.png" class="player-char player-walking" id="player">
            <div class="player-hud">
                <div class="voice-feedback" id="voiceFeedback"></div>
                <div class="breath-gauge-container"><div class="breath-gauge-bar" id="micBar"></div></div>
            </div>
            <div id="objContainer"></div>
        </div>

        <div class="hud-layer">
            <div style="position:absolute; bottom:30px; left:50%; transform:translateX(-50%); font-size:10px;">GOALまで</div>
            <div style="position:absolute; bottom:10px; left:50%; transform:translateX(-50%); width:90%; height:16px; background:rgba(0,0,0,0.6); border:2px solid #fff; border-radius:10px; overflow:hidden;">
                <div id="distBar" style="height:100%; width:0%; background:#8e44ad;"></div>
            </div>
            <div class="map-panel" id="mapPanel">
                <div style="position:absolute; bottom:10px; left:0; width:100%; height:2px; background:#2ecc71;"></div>
                <div style="position:absolute; bottom:10px; left:20px; width:0; height:0; border-left:6px solid transparent; border-right:6px solid transparent; border-bottom:12px solid #fff; transform:translate(-50%,0);"></div>
            </div>
            <div id="naviBubble" class="navi-bubble">
                <img src="./nightgame/chara.png" class="navi-icon">
                <div id="naviText" class="navi-text">...</div>
            </div>
            <div class="header-panel">
                <div class="status-box">
                    <div class="difficulty-stars" id="diffStars"></div>
                    <div class="life-container" id="lifeDisplay">❤❤❤</div>
                    <div>GENESIS AREA</div>
                    <div style="margin-top:2px;">捕獲数: <span id="sessionCount" style="color:#f093fb; font-size:18px;">0</span></div>
                </div>
                <button onclick="togglePause()" style="background:#e74c3c; color:#fff; border:2px solid #fff; padding:8px 15px; cursor:pointer;">中断</button>
            </div>
        </div>

        <div class="overlay-screen" id="startOverlay">
            <h2 style="color:#f093fb; text-shadow: 2px 2px 0 #8e44ad;">GENESIS EXPLORE</h2>
            <p style="font-size:14px;">他次元の生体データを捕獲せよ<br><span style="color:#f093fb">「はっ！」</span>で捕獲 / <span style="color:#3498db">「ぱっ！」</span>で隕石破壊</p>
            <div class="level-select-container">
                <div class="level-btn" onclick="gameStart(1)"><div>LEVEL 1</div><div class="difficulty-stars"><img src="./nightgame/star.png"></div></div>
                <div class="level-btn" onclick="gameStart(2)"><div>LEVEL 2</div><div class="difficulty-stars"><img src="./nightgame/star.png"><img src="./nightgame/star.png"></div></div>
                <div class="level-btn" onclick="gameStart(3)"><div>LEVEL 3</div><div class="difficulty-stars"><img src="./nightgame/star.png"><img src="./nightgame/star.png"><img src="./nightgame/star.png"></div></div>
                <div class="level-btn" onclick="gameStart(4)"><div>LEVEL 4</div><div class="difficulty-stars"><img src="./nightgame/star.png"><img src="./nightgame/star.png"><img src="./nightgame/star.png"><img src="./nightgame/star.png"></div></div>
            </div>
        </div>

        <div class="overlay-screen hidden" id="pauseOverlay" style="background: rgba(0,0,0,0.6);">
            <h2>一時切断中</h2>
            <button class="pixel-btn" onclick="togglePause()">再開</button>
            <button class="pixel-btn" style="background:#555;" onclick="location.href='genesis_hub.html'">帰還</button>
        </div>

        <div class="overlay-screen hidden" id="gameOverOverlay">
            <h2 style="color:#e74c3c; font-size:40px;">CONNECTION LOST</h2>
            <p>デブリ衝突により強制切断</p>
            <button class="pixel-btn" onclick="location.reload()">再接続</button>
            <button class="pixel-btn" style="background:#555;" onclick="location.href='genesis_hub.html'">帰還</button>
        </div>

        <div class="overlay-screen hidden" id="gameClearOverlay">
            <h2 style="color:#2ecc71; font-size:40px;">DOWNLOAD COMPLETE</h2>
            <p>探索終了！<br><br>捕獲した検体: <span id="resultSessionCount" style="font-size:24px; color:#f093fb;">0</span> 体</p>
            <div id="caughtPreview" style="display:flex; gap:5px; margin:10px 0; justify-content:center; flex-wrap:wrap;"></div>
            <button class="pixel-btn" id="saveBtn" onclick="finishExploration()">保存して帰還</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getFirestore, doc, updateDoc, arrayUnion, collection, getDocs, query, limit } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        const DIFFICULTY_RULES = {
            1: { maxMonsters: 3,  totalMeteors: 2, spawnRate: 200 },
            2: { maxMonsters: 5,  totalMeteors: 3, spawnRate: 180 }, 
            3: { maxMonsters: 8,  totalMeteors: 5, spawnRate: 150 },
            4: { maxMonsters: 10, totalMeteors: 8, spawnRate: 120 }
        };

        const firebaseConfig = {
            apiKey: "AIzaSyCUWMn07YntLyB8m4q5-zHmiwjYOz1c_nk",
            authDomain: "bremons.firebaseapp.com",
            projectId: "bremons",
            storageBucket: "bremons.firebasestorage.app",
            messagingSenderId: "30413071482",
            appId: "1:30413071482:web:f62c34349b13e6c6ce47c3",
            measurementId: "G-4D4FCXGDBG"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const uid = localStorage.getItem('user_uid');
        if(!uid) location.href = 'index.html';

        let globalMonsterPool = [];
        let caughtMonsters = [];
        let currentLevel = 1;
        let currentRule = DIFFICULTY_RULES[1];
        let maxLives = 3;
        let currentLives = 3;
        let sessionCaught = 0;
        let monstersSpawnedTotal = 0;
        let meteorsSpawnedTotal = 0;
        let goalSpawned = false;
        let goalDelayTimer = 0;
        let isGameRunning = false;
        let isPaused = false;
        let groundOffset = 0;
        let gameSpeed = 1.5; 
        let shakeTrauma = 0;
        let gameObjects = [];
        let spawnTimer = 0;
        let naviTimer = 0;

        const THOUSAND_INDEX = 24;
        let micConfig = {
            noiseThreshold: 0.05,
            haProfile: [0.096, 0.101, 0.044, 0.005, 0.005, 0.019, 0.030, 0.036, 0.038, 0.010, 0.001, 0.004, 0.018, 0.055, 0.069, 0.040, 0.023, 0.012, 0.027, 0.040, 0.029, 0.022, 0.009, 0.038],
            paProfile: [0.032, 0.041, 0.014, 0.022, 0.009, 0.017, 0.005, 0.022, 0.011, 0.010, 0.029, 0.092, 0.135, 0.139, 0.051, 0.013, 0.009, 0.012, 0.014, 0.014, 0.008, 0.009, 0.017, 0.007]
        };
        try {
            const saved = localStorage.getItem('mic_config_v2');
            if(saved) micConfig = JSON.parse(saved);
        } catch(e){}
        
        let audioContext, analyser, dataArray;
        let voiceCooldown = 0;

        async function fetchGlobalData() {
            try {
                const q = query(collection(db, "public_genesis_monsters"), limit(30));
                const snapshot = await getDocs(q);
                snapshot.forEach(doc => {
                    const d = doc.data();
                    if(d.code) globalMonsterPool.push({ code: d.code, creator: d.creatorName || "Unknown" });
                });
                if(globalMonsterPool.length === 0) {
                    globalMonsterPool.push({ code: "BM-0080-8080", creator: "System_A" });
                    globalMonsterPool.push({ code: "BM-04FF-40FF", creator: "System_B" });
                }
            } catch(e) { globalMonsterPool.push({ code: "BM-0080-8080", creator: "System_Offline" }); }
        }

        window.gameStart = async function(level) {
            currentLevel = level || 1;
            currentRule = DIFFICULTY_RULES[currentLevel];
            const starContainer = document.getElementById('diffStars');
            starContainer.innerHTML = '';
            for(let i=0; i<currentLevel; i++) {
                const img = document.createElement('img'); img.src = './nightgame/star.png'; starContainer.appendChild(img);
            }
            await fetchGlobalData();

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                await audioContext.resume(); 
                analyser = audioContext.createAnalyser();
                const src = audioContext.createMediaStreamSource(stream);
                src.connect(analyser);
                analyser.fftSize = 1024;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
            } catch(e) { console.log("Mic error"); }

            document.getElementById('startOverlay').classList.add('hidden');
            isGameRunning = true;
            showNavi("リンク確立！<br>ゴールを目指せ！");
            requestAnimationFrame(gameLoop);
        };

        window.togglePause = function() {
            if(!isGameRunning) return;
            isPaused = !isPaused;
            document.getElementById('pauseOverlay').classList.toggle('hidden', !isPaused);
            if(!isPaused) requestAnimationFrame(gameLoop);
        };

        function gameLoop() {
            if(!isGameRunning || isPaused) return;
            groundOffset -= gameSpeed;
            if(groundOffset <= -40) groundOffset = 0;
            document.getElementById('groundLayer').style.backgroundPosition = `${groundOffset}px 0`;

            const totalTarget = currentRule.maxMonsters + currentRule.totalMeteors;
            const currentTotal = monstersSpawnedTotal + meteorsSpawnedTotal;
            document.getElementById('distBar').style.width = Math.min(100, (currentTotal / totalTarget) * 100) + "%";

            if(analyser) processVoice();

            const allSpawned = (monstersSpawnedTotal >= currentRule.maxMonsters) && (meteorsSpawnedTotal >= currentRule.totalMeteors);
            if(allSpawned && !goalSpawned) {
                goalDelayTimer++;
                if(goalDelayTimer > 150) { spawnGoalFlag(); goalSpawned = true; showNavi("座標固定！<br>ゴールが出現した！"); }
            }

            spawnTimer++;
            if(!allSpawned && spawnTimer > currentRule.spawnRate) {
                const canMon = monstersSpawnedTotal < currentRule.maxMonsters;
                const canMet = meteorsSpawnedTotal < currentRule.totalMeteors;
                if(canMon && canMet) Math.random() < 0.5 ? spawnMonster() : spawnMeteor();
                else if(canMon) spawnMonster();
                else if(canMet) spawnMeteor();
                spawnTimer = 0;
            }

            updateObjects(); updateMapUI(); updateShake(); updateNavi();
            requestAnimationFrame(gameLoop);
        }

        function spawnMonster() {
            monstersSpawnedTotal++;
            const data = globalMonsterPool[Math.floor(Math.random() * globalMonsterPool.length)];
            const container = document.createElement('div');
            container.className = 'game-obj monster-container';
            container.style.left = (window.innerWidth + 100) + 'px';
            const label = document.createElement('div');
            label.className = 'monster-label'; label.innerText = data.creator;
            container.appendChild(label);
            const cvs = document.createElement('canvas');
            cvs.width = 20; cvs.height = 20; cvs.className = 'monster-canvas';
            drawFromCode(cvs, data.code);
            container.appendChild(cvs);
            document.getElementById('objContainer').appendChild(container);
            gameObjects.push({ el: container, type: 'monster', x: window.innerWidth + 100, code: data.code, creator: data.creator, alive: true });
        }

        function spawnMeteor() {
            meteorsSpawnedTotal++;
            const el = document.createElement('img'); 
            el.src = './nightgame/meteo.png'; 
            el.className = 'game-obj meteo-obj';
            document.getElementById('objContainer').appendChild(el);
            
            const startX = window.innerWidth + Math.random() * 200;
            const startY = -150;
            const targetX = window.innerWidth * 0.15; 
            const targetY = window.innerHeight - 150; 
            
            // 角度計算
            const angleRad = Math.atan2(targetY - startY, targetX - startX);
            const speed = gameSpeed + 2;
            
            // ★角度修正: 元画像が「下向き(90度)」なので、進行方向から90度引くことで頭を向ける
            // (例: 真下(90度)へ飛ぶ場合 -> 90 - 90 = 0度回転。 元画像(下向き)のまま。正解)
            // (例: 真右(0度)へ飛ぶ場合 -> 0 - 90 = -90度回転。 元画像(下向き)を左に90度回すと右向き。正解)
            const angleDeg = (angleRad * 180 / Math.PI) - 90;
            el.style.transform = `rotate(${angleDeg}deg)`;

            gameObjects.push({ el: el, type: 'meteor', x: startX, y: startY, vx: Math.cos(angleRad) * speed, vy: Math.sin(angleRad) * speed, alive: true });
        }

        function spawnGoalFlag() {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#aaa'; ctx.fillRect(5, 10, 5, 118);
            ctx.fillStyle = '#fff'; ctx.fillRect(10, 10, 50, 40);
            ctx.fillStyle = '#8e44ad'; ctx.fillRect(10, 10, 25, 20); ctx.fillRect(35, 30, 25, 20);
            const img = document.createElement('img'); img.src = canvas.toDataURL(); img.className = 'game-obj goal-obj'; img.style.left = (window.innerWidth + 50) + 'px';
            document.getElementById('objContainer').appendChild(img);
            gameObjects.push({ el: img, type: 'goal', x: window.innerWidth + 50, alive: true });
        }

        function updateObjects() {
            const playerX = window.innerWidth * 0.15; const pHitY = window.innerHeight - 120;
            gameObjects.forEach(obj => {
                if(!obj.alive) return;
                if(obj.type === 'monster') {
                    obj.x -= gameSpeed; obj.el.style.left = obj.x + 'px';
                    if(obj.x < playerX + 80 && obj.x > playerX + 70) {
                        obj.alive = false; obj.el.style.transition = "transform 1s";
                        obj.el.style.transform = "translate(-200px, -200px) rotate(-90deg)";
                        setTimeout(() => removeObject(obj), 1000);
                        showEffect("MISS...", "#555", playerX, pHitY - 50);
                    }
                } else if(obj.type === 'meteor') {
                    obj.x += obj.vx; obj.y += obj.vy; 
                    obj.el.style.left = obj.x + 'px'; obj.el.style.top = obj.y + 'px';
                    if(Math.abs(obj.x - playerX) < 60 && Math.abs(obj.y - pHitY) < 60) playerHit(obj);
                    if(obj.y > window.innerHeight) removeObject(obj);
                } else if(obj.type === 'goal') {
                    obj.x -= gameSpeed; obj.el.style.left = obj.x + 'px';
                    if(obj.x < playerX + 80 && obj.x > playerX - 50) gameClear();
                }
            });
        }

        function processVoice() {
            if(voiceCooldown > 0) { voiceCooldown--; return; }
            analyser.getByteFrequencyData(dataArray);
            let sum = 0; for(let i=0; i<dataArray.length; i++) sum += dataArray[i];
            let avg = sum / dataArray.length;
            document.getElementById('micBar').style.width = Math.min(100, avg * 3) + "%"; // 感度UP

            let maxAmp = 0; for(let i=0; i<THOUSAND_INDEX; i++) if(dataArray[i]/255 > maxAmp) maxAmp = dataArray[i]/255;
            if(maxAmp < micConfig.noiseThreshold) return;

            let haDist = 0, paDist = 0;
            for(let i=0; i<THOUSAND_INDEX; i++) {
                const val = dataArray[i] / 255.0;
                haDist += Math.pow(micConfig.haProfile[i] - val, 2);
                paDist += Math.pow(micConfig.paProfile[i] - val, 2);
            }
            const haScore = 1 / (1 + Math.sqrt(haDist));
            const paScore = 1 / (1 + Math.sqrt(paDist));

            if (haScore > 0.6 || paScore > 0.6) {
                if (haScore > paScore + 0.05) { triggerAction("はっ"); voiceCooldown = 15; }
                else if (paScore > haScore + 0.05) { triggerAction("ぱっ"); voiceCooldown = 15; }
            }
        }

        function triggerAction(type) {
            if(isPaused) return;
            const fb = document.getElementById('voiceFeedback'); fb.innerText = type + "！"; fb.style.opacity = 1;
            setTimeout(() => fb.style.opacity = 0, 500);
            const playerX = window.innerWidth * 0.15;
            if(type === "はっ") {
                const targets = gameObjects.filter(o => o.type === 'monster' && o.alive && o.x > playerX && o.x < playerX + 400);
                if(targets.length > 0) captureMonster(targets[0]);
            } else if(type === "ぱっ") {
                const targets = gameObjects.filter(o => o.type === 'meteor' && o.alive && o.x > playerX - 100 && o.x < playerX + 700);
                if(targets.length > 0) destroyMeteor(targets[0]);
            }
        }

        function captureMonster(obj) {
            obj.alive = false; obj.el.style.transition = "all 0.5s";
            obj.el.style.transform = "scale(0) rotate(360deg)"; obj.el.style.opacity = "0";
            setTimeout(() => removeObject(obj), 500);
            caughtMonsters.push({ code: obj.code, creator: obj.creator, caughtAt: new Date().toISOString() });
            sessionCaught++; document.getElementById('sessionCount').innerText = sessionCaught;
            showEffect("GET!", "#f093fb", window.innerWidth * 0.15, window.innerHeight - 200);
        }

        function destroyMeteor(obj) {
            obj.alive = false; shakeTrauma = 1.0;
            // 破壊時アニメーション
            const currentRot = obj.el.style.transform;
            obj.el.animate([
                { transform: `${currentRot} scale(1)`, opacity: 1, filter: 'brightness(2)' },
                { transform: `${currentRot} scale(2)`, opacity: 0 }
            ], { duration: 300, fill: 'forwards' });
            setTimeout(() => removeObject(obj), 300);
            showEffect("BREAK!", "#e74c3c", obj.x, obj.y);
        }

        function playerHit(obj) {
            obj.alive = false; removeObject(obj); shakeTrauma = 1.0; currentLives--; updateLife();
            document.getElementById('player').classList.add('player-damage');
            setTimeout(() => document.getElementById('player').classList.remove('player-damage'), 1000);
            showEffect("OUCH!", "#e74c3c", window.innerWidth * 0.15, window.innerHeight - 200);
            if(currentLives <= 0) gameOver();
        }

        function updateLife() {
            let h = ""; for(let i=0; i<3; i++) h += (i < currentLives) ? "❤" : "<span style='color:#555'>❤</span>";
            document.getElementById('lifeDisplay').innerHTML = h;
        }

        function updateMapUI() {
            const mapPanel = document.getElementById('mapPanel'); mapPanel.querySelectorAll('.dot-gen').forEach(d => d.remove());
            const playerX = window.innerWidth * 0.15;
            gameObjects.forEach(obj => {
                if(!obj.alive || obj.type === 'goal') return;
                const dx = obj.x - playerX;
                if(dx > -100 && dx < window.innerWidth) {
                    const dot = document.createElement('div'); dot.className = 'map-dot dot-gen ' + (obj.type==='monster' ? 'dot-monster':'dot-meteor');
                    dot.style.left = (20 + (dx / window.innerWidth) * 80) + 'px';
                    dot.style.top = (obj.type==='meteor' ? 50 : 100) + 'px';
                    mapPanel.appendChild(dot);
                }
            });
        }

        function updateShake() {
            shakeTrauma = Math.max(0, shakeTrauma - 0.05);
            if(shakeTrauma > 0) {
                const dx = (Math.random() - 0.5) * 20 * shakeTrauma; const dy = (Math.random() - 0.5) * 20 * shakeTrauma;
                document.getElementById('gameWorld').style.transform = `translate(${dx}px, ${dy}px)`;
            } else { document.getElementById('gameWorld').style.transform = 'none'; }
        }

        function showNavi(html) {
            document.getElementById('naviText').innerHTML = html; document.getElementById('naviBubble').classList.add('show'); naviTimer = 300;
        }
        function updateNavi() {
            if(naviTimer > 0) { naviTimer--; if(naviTimer <= 0) document.getElementById('naviBubble').classList.remove('show'); }
        }
        function removeObject(obj) { obj.alive = false; if(obj.el && obj.el.parentNode) obj.el.remove(); }
        function showEffect(text, color, x, y) {
            const el = document.createElement('div'); el.className = 'effect-text'; el.innerText = text; el.style.color = color;
            el.style.left = x+'px'; el.style.top = y+'px'; document.body.appendChild(el); setTimeout(() => el.remove(), 800);
        }
        function gameOver() { isGameRunning = false; document.getElementById('gameOverOverlay').classList.remove('hidden'); }
        function gameClear() {
            isGameRunning = false; document.getElementById('resultSessionCount').innerText = sessionCaught;
            document.getElementById('gameClearOverlay').classList.remove('hidden');
            const c = document.getElementById('caughtPreview');
            caughtMonsters.forEach(m => {
                const cvs = document.createElement('canvas'); cvs.width = 30; cvs.height = 30; cvs.style.background="#222"; cvs.style.border="1px solid #8e44ad";
                drawFromCode(cvs, m.code); c.appendChild(cvs);
            });
        }
        window.finishExploration = async function() {
            const btn = document.getElementById('saveBtn'); btn.innerText = "保存中..."; btn.disabled = true;
            try {
                if(caughtMonsters.length > 0) {
                    const userRef = doc(db, "users", uid);
                    await updateDoc(userRef, { genesisCaught: arrayUnion(...caughtMonsters) });
                }
                location.href = "genesis_hub.html";
            } catch(e) { console.error(e); alert("保存失敗"); location.href = "genesis_hub.html"; }
        };

        const SCALE_COLORS = [
            { hex: "#FF9AA2", eye: "#C85A62" }, { hex: "#FFB7B2", eye: "#D67C77" },
            { hex: "#FFDAC1", eye: "#D4A88F" }, { hex: "#FFE6A7", eye: "#C9B475" },
            { hex: "#FFF5BA", eye: "#C4BD87" }, { hex: "#C1E1C1", eye: "#8FAB8F" },
            { hex: "#B2E0E6", eye: "#81ADB3" }, { hex: "#AEEEEE", eye: "#7FBDBD" },
            { hex: "#ADD8E6", eye: "#7FA8B6" }, { hex: "#B4C6E7", eye: "#8396B7" },
            { hex: "#C3B1E1", eye: "#917FB1" }, { hex: "#E6B0AA", eye: "#B37D77" }
        ];
        function drawFromCode(canvas, code) {
            if(!code) return; const ctx = canvas.getContext('2d'); const parts = code.split('-'); 
            if(parts.length < 3) return;
            let raw = parts[1] + parts[2]; 
            const p1 = parseInt(raw.substring(0,2), 16); const p2 = parseInt(raw.substring(2,4), 16);
            const p3 = parseInt(raw.substring(4,6), 16); const p4 = parseInt(raw.substring(6,8), 16);
            drawMonster(ctx, p1, p2, p3, p4);
        }
        function drawMonster(ctx, noteIdx, pitchVal, typeVal, rndVal) {
            const colorData = SCALE_COLORS[noteIdx % 12]; const mainColor = colorData.hex; const eyeColor = colorData.eye;
            const shadowColor = adjustBrightness(mainColor, -25); const outlineColor = adjustBrightness(mainColor, -40);
            ctx.clearRect(0, 0, 20, 20); 
            const masterSeed = (noteIdx << 24) ^ (pitchVal << 16) ^ (typeVal << 8) ^ rndVal; const rng = new Xorshift32(masterSeed);
            const gridSize = 20; const grid = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));
            const centerX = 9.5; const centerY = 10.5; let squash = 0.7 + (pitchVal / 255) * 0.3;
            const baseRadiusW = 8.0; const baseRadiusH = 8.0 * squash;
            for (let y = 0; y < gridSize; y++) for (let x = 0; x < gridSize; x++) { const dx = x - centerX; const dy = y - centerY; let dynamicRadiusW = baseRadiusW * (1.0 + dy * 0.04); if ((dx*dx)/(dynamicRadiusW*dynamicRadiusW) + (dy*dy)/(baseRadiusH*baseRadiusH) <= 0.95) grid[y][x] = 2; }
            const partsType = Math.floor(rng.next() * 4); 
            let bodyTopY = 0; for(let y=0; y<gridSize/2; y++) { if(grid[y][9] === 2) { bodyTopY = y; break; } }
            const earX = Math.floor(centerX - 2); const earBaseY = bodyTopY;
            if (earBaseY >= 1) { if (partsType === 0) { grid[earBaseY][earX]=2; grid[earBaseY][earX-1]=2; grid[earBaseY-1][earX]=2; grid[earBaseY-1][earX-1]=2; grid[earBaseY][earX-1]=4; } else if (partsType === 1) { grid[earBaseY-1][earX]=2; grid[earBaseY-2][earX]=2; grid[earBaseY-1][earX]=4; } else if (partsType === 2) { grid[earBaseY][earX-1]=2; grid[earBaseY-1][earX-1]=2; grid[earBaseY-1][earX-2]=2; grid[earBaseY][earX-1]=4; } }
            let bodyBottomY = gridSize-1; for(let y=gridSize-1; y>gridSize/2; y--) { if(grid[y][9] === 2) { bodyBottomY = y; break; } }
            const legX = Math.floor(centerX - 3); if (bodyBottomY < gridSize-1 && rng.next() > 0.3) { grid[bodyBottomY+1][legX] = 2; grid[bodyBottomY+2][legX] = 1; grid[bodyBottomY+1][legX-1] = 2; grid[bodyBottomY+2][legX-1] = 1; }
            for (let y=0; y<gridSize; y++) for(let x=0; x<10; x++) if(grid[y][x]!==0) grid[y][19-x]=grid[y][x];
            const finalGrid = JSON.parse(JSON.stringify(grid)); for (let y=0; y<gridSize; y++) for(let x=0; x<gridSize; x++) if(grid[y][x]===2 || grid[y][x]===4) { let isEdge=false; [[0,-1],[0,1],[-1,0],[1,0]].forEach(([nx,ny])=>{if(!grid[y+ny]||grid[y+ny][x+nx]===0)isEdge=true;}); if(isEdge)finalGrid[y][x]=1; }
            for (let y=0; y<gridSize; y++) for(let x=0; x<gridSize; x++) if(finalGrid[y][x]===2) { if(x>centerX+4 && y>centerY+3 && (x+y)%2===0) finalGrid[y][x]=4; }
            for (let y=0; y<gridSize; y++) for(let x=0; x<gridSize; x++) { const val=finalGrid[y][x]; if(val!==0){ if(val===1)ctx.fillStyle=outlineColor; else if(val===2)ctx.fillStyle=mainColor; else if(val===4)ctx.fillStyle=shadowColor; ctx.fillRect(x,y,1,1); } }
            const eyeY = Math.floor(centerY); const eyeX_L = 6; const eyeX_R = 12; let eyePattern = typeVal % 3;
            drawSpecifiedEye(ctx, eyeX_L, eyeY, eyeColor, shadowColor, eyePattern); drawSpecifiedEye(ctx, eyeX_R, eyeY, eyeColor, shadowColor, eyePattern, false);
        }
        function drawSpecifiedEye(ctx, x, y, color, shadow, pattern, isRight=false) {
            ctx.fillStyle = "#fff"; if (pattern === 0) { ctx.fillRect(x, y, 2, 2); ctx.fillStyle = color; ctx.fillRect(x, y+2, 2, 2); } else if (pattern === 1) { ctx.fillRect(x, y, 2, 2); ctx.fillStyle = shadow; ctx.fillRect(x, y+2, 2, 1); ctx.fillStyle = color; ctx.fillRect(x, y+3, 2, 1); } else { ctx.fillRect(x, y, 2, 2); ctx.fillStyle = shadow; ctx.fillRect(x, y+2, 2, 1); ctx.fillStyle = color; ctx.fillRect(x, y+3, 2, 1); const decoX = x + 2; ctx.fillStyle = shadow; ctx.fillRect(decoX, y+2, 1, 1); ctx.fillStyle = color; ctx.fillRect(decoX, y+1, 1, 1); }
        }
        class Xorshift32 { constructor(seed) { this.state = seed | 0; if (this.state === 0) this.state = 0xdeadbeef; } next() { let x = this.state; x ^= x << 13; x ^= x >>> 17; x ^= x << 5; this.state = x; return (x >>> 0) / 4294967296; } }
        function adjustBrightness(hex, p) { let r = parseInt(hex.slice(1,3), 16); let g = parseInt(hex.slice(3,5), 16); let b = parseInt(hex.slice(5,7), 16); r = Math.max(0, Math.min(255, r + Math.round(2.55 * p))); g = Math.max(0, Math.min(255, g + Math.round(2.55 * p))); b = Math.max(0, Math.min(255, b + Math.round(2.55 * p))); return "#" + (1 << 24 | r << 16 | g << 8 | b).toString(16).slice(1); }
    </script>
</body>
</html>